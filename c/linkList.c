/*
 *  ΠΑΝΕΠΙΣΤΗΜΙΟ ΠΑΤΡΩΝ
 *  ΤΜΗΜΑ ΗΛΕΚΤΡΟΛΟΓΩΝ ΜΗΧΑΝΙΚΩΝ
 *  ΜΑΘΗΜΑ: ΑΡΧΕΣ ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΥ
 *
 *  Χειρισμός διασυνδεδεμένης λίστας αντικειμένων
 *
 *
 *  ΠΑΤΡΑ 15-5-2014
 *
 *
 *  Τα δεδομένα της λίστας αποθηκεύονται σε δομή τύπου

typedef struct node {
	int num ;						// Το περιεχόμενο της λίστας
	struct node *next ;				// Η διεύθυνση του επόμενου στοιχείου
} NODE ;

 *
 *  Εχουν υλοποιηθεί οι εξής συναρτήσεις
 *
 *  initList:			Δημιουργία τυχαίας λίστας δεδομένων
 *  append2List:		Προσθήκη νέων εγγραφών στο τέλος του αρχείου
 *  printList:			Εκτύπωση των δεδομένων της λιστας
 *  insert2List:		Παρεμβολή κόμβου στην λίστα
 *  deleteList:			Διαγραφή όλων των εγγραφών
 *
*/

#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	int num ;						// Το περιεχόμενο της λίστας
	struct node *next ;				// Η διεύθυνση του επόμενου στοιχείου
} NODE ;

NODE *Head = NULL ;

// ***********************************************************************
// Πρωτότυπα συναρτήσεων
// ***********************************************************************
int initList( int num ) ;
int append2List( int num ) ;
void printList( NODE *start ) ;
int insert2List( int after, int num  ) ;
void deleteList( NODE *start ) ;


/********************************************************************************
Δημιουργία της λίστας η οποία έχει num κόμβους τύπου NODE
Το περιεχόμενο των εγγραφών είναι τυχαίο
Επιστρέφει τον αριθμό των κόμβων που πρόσθεσε με επιτυχία, αρνητικό νούμερο σε σφάλμα
*******************************************************************************/
int initList( int num )
{
	NODE *p ;
	int i ;

	Head = malloc( sizeof(NODE)) ;
	if ( Head == NULL )
		return -1 ;
	Head->num = rand()%100 ;
	Head->next = NULL ;
	for( i = 1, p = Head ; i < num ; i++ )
	{
		// Δεσμεύουμε μνήμη για τον νέο κόμβο που θα κατασκευάσουμε
		p->next = malloc( sizeof(NODE)) ;
		if ( p->next == NULL )
			return i ;
		// "μπαίνουμε" στον νέο κόμβο και τοποθετούμε τιμές
		p = p->next ;
		p->num = rand()%100 ;
	}
	p->next = NULL ;
	return num ;
}


/********************************************************************************
Προσθέτουμε num κόμβους στο τέλος της λίστας
Το περιεχόμενο των εγγραφών είναι τυχαίο
Επιστρέφει τον αριθμό των κόμβων που πρόσθεσε με επιτυχία, αρνητικό νούμερο σε σφάλμα
*******************************************************************************/
int append2List( int num )
{
	NODE *p ;
	int i ;

	if ( Head == NULL )
		return initList( num ) ;

	p = Head ;
	while ( p->next != NULL )
		p = p->next ;

	for( i = 0 ; i < num ; i++ )
	{
		// Δεσμεύουμε μνήμη για τον νέο κόμβο που θα κατασκευάσουμε
		p->next = malloc( sizeof(NODE)) ;
		if ( p->next == NULL )
			return i ;
		// "μπαίνουμε" στον νέο κόμβο και τοποθετούμε τιμές
		p = p->next ;
		p->num = rand()%100 ;
	}
	p->next = NULL ;
	return num ;
}


/********************************************************************************
Εκτυπώνει το περιεχόμενο της λίστας
*******************************************************************************/
void printList( NODE *Start )
{
	while ( Start != NULL )
	{
		printf( "%d\n", Start->num ) ;
		Start = Start->next ;
	}
}

/********************************************************************************
Προσθέτουμε ένα κόμβο με περιεχόμενο τον αριθμό num ακριβώς μετά τον κόμβο με τον αριθμό start
Επιστρέφει 1 αν προστέθηκε με επιτυχία ο κόμβος, 0 αν δεν βρέθηκε κόμβος με τιμή start, αρνητικό νούμερο σε σφάλμα
*******************************************************************************/
int insert2List( int after, int num  )
{
	NODE *p, *p1 ;

	//	Αν η λίστα είναι κενή επιστρέφω 0
	if ( Head == NULL )
		return 0 ;

	//	Ψάχνω στην λίστα για να βρώ κόμβο που έχει περιεχόμενο το start
	p = Head ;
	while ( p->next != NULL )
		if ( p->num != after )
			p = p->next ;
		else
			break ;

	//	Αν φτάσω στο τέλος της λίστας χωρίς να βρώ το start επιστρέφω 0
	if ( p->num != after )
		return 0 ;

	//	Βρήκα το start και παρεμβάλλω έναν νέο κόμβο που έχει την τιμή num
	// Αποθηκεύω την τιμή γιατί πρέπει να την τοποθετήσω στον νέο κόμβο που θα φτιάξω
	p1 = p->next ;
	p->next = malloc( sizeof(NODE)) ;
	if ( p->next == NULL )
		return -1 ;
	// "μπαίνουμε" στον νέο κόμβο και τοποθετούμε τιμές
	p = p->next ;
	p->num = num ;
	p->next = p1 ;
	return 1 ;
}



/********************************************************************************
Διαγραφή όλων των εγγραφών μετά την θέση start
*******************************************************************************/
void deleteList( NODE *start )
{
	NODE *p ;

	if ( start->next != NULL )
	{
		p = start ->next ;
		start->next = NULL ;
	}

	 while (p) {
	        start = p->next;
	        free(p);
	        p = start ;
	    }
}


// *******************************************************************************
int main(void)
{
	printf( "InitList %d\n", initList( 10 ) ) ;
	printList( Head ) ;
	printf( "append2List %d\n", append2List( 10 ) ) ;
	printList( Head ) ;
	printf( "insert2List %d\n", insert2List( 15, 28  ) ) ;
	printList( Head ) ;
	deleteList( Head ) ;
	free( Head ) ;

	return EXIT_SUCCESS;
}
